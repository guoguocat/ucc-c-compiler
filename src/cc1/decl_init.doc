store range inits separately, e.g.

struct A
{
	int i, j;
} x[] = {
  [0 ... 5] = { 1, 2, },
};

We store the init { 1, 2 } in .range_inits (immutable once stored).
Then each of .inits[0 ... 5] is of type decl_init_copy, and its .bits.range_copy
points into the .range_inits.

if we then have:
  [1].j = 3,

this takes the .range_copy, and if its constant, we copy it
into *di, and alter it accordingly, if it's constant.

The another annoying case is that we're replacing something with a range-init,
e.g.
struct A x[] = {
	{ 1, 2 },
	[0 ... 5].j = 99
};

This should generate { { 1, 99 }, { 0, 99 }... }
i.e. the first range init should partially replace [0].
